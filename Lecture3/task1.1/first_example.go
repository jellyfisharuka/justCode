package main

import (
	"fmt"
	"time"
)
//в этом примере у нас будет deadlock.
func main() {
	channel := make(chan int) // тут у нас создается канал для связи
	for i := 0; i < 5; i++ {
		go sleepyGopher(i, channel) //горутины и каналы
	}
	for i := 0; i < 5; i++ {
		gopherID := <-channel // Получает значение от канала когда <-channel это значит получает значение от канала. А если наоборот то означает отправку в канал channel
		//главная горутина пытается получить значение из канала, но ни одна из запущенных горутин не отправляет значения в этот канал до тех пор, пока она не завершит выполнение функции sleepyGopher. 
        //Таким образом, главная горутина блокируется, ожидая получения значения из канала.
		fmt.Println("gopher ", gopherID, " has finished sleeping")
		<-channel
		//тут я снова пытаюсь получить значение из канала.Это делается после того, как первая горутина уже отправила значение в канал. 
		//Однако, так как второй вызов <-channel не имеет соответствующей горутины, которая бы отправила второе значение в канал, то программа также блокируется на этой строке.
	}
}
func sleepyGopher(id int, channel chan int) { // у нас тут канал как аргумент
	time.Sleep(3 * time.Second)
	fmt.Println("... ", id, " snore ...")
	channel <- id // Отправляет значение обратно к main
}



